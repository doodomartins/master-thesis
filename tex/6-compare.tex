In this chapter we will present an analysis over the five presented method on previous section. The first two analysis has focus on the complexity and performance of the algorithms. However, we are not interested only in efficient methods, our main goal was achieve an method with no information leakage against a timing side-channel attack. Hence, we demonstrate an time-variance analysis for each proposed root-finding method. After that, we present an security analysis over the algorithm. Remarking that $n = 2^m$ are the size fields, and $t$ the degree of polynomial.

\section{Complexity analysis}
In order to compare the complexity of the algorithm, we use the Big $\mathcal{O}$ notation. This asymptotic notation permits to us classify the algorithms according to their behaviour when the inputs grows. 

\begin{table}[ht]
\centering
\label{tab:complexity}
\caption{Complexity comparison}
\begin{tabular}{ll}
Method                                  &                \\ \hline
Exhaustive search                       & $\mathcal{O}(2^mt)$ \\
Permuted exhaustive                     & $\mathcal{O}(2^mt)$ \\
Linearized Polynomials                  & $\mathcal{O}(2^m)$ \\
Constant Linearized Polynomials         & $\mathcal{O}(2^m)$ \\
Berlekamp trace algorithm               & $\mathcal{O}(mt^2)$ \\
Iterative Berlekamp trace algorithm     & $\mathcal{O}(m^2t^2)$ \\
Successive resultant algorithm          & $\mathcal{O}(t^2m^3)$ \\
Constant Successive resultant algorithm & $\mathcal{O}(t^2m^3)$ \\
Rabin root finding                      & $\mathcal{O}(t^2m)$
\end{tabular}
\end{table}

As we can note, the most asymptotic efficient method was the Rabin root finding method. However, this asymptotic could not reflect the execution timing of the algorithm for parameters used in code-based schemes. This happens because the big $\mathcal{O}$ notation does not consider constants and the asymptotic complexity was for all $m$ and $t$ grater then $m_0$ and $t_0$ respectively, and the parameters used on code-based cryptosystems could be smaller then the $m_0$ and $t_0$.



\section{Performance analysis}
To present a more careful analysis, we present a execution time analysis of each presented algorithm. This comparison gives an idea of the real execution cost. All root finding method was performed over and random polynomial of degree $t$ over $\mathbb{F}_2^m$, for $t = 50$ until $t = 300$ and $n = 2^10$ to $n = 2^{18}$. For each polynomial, we take the average time of 10 executions.
 



\begin{figure}[!ht]
\centering
\begin{subfigure}{0.48\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{fig/charts_sra(1).pdf}
  \caption{Execution time comparison between different $m$ and $t$ for Successive resultant algorithm.}
  \label{fig:time-SRA}
\end{subfigure}
\begin{subfigure}{0.48\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{fig/charts_bta.pdf}
  \caption{Execution time comparison between different $m$ and $t$ for Successive resultant algorithm.}
  \label{fig:time-BTA}
\end{subfigure}

\begin{subfigure}{0.48\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{fig/charts_exha.pdf}
  \caption{Execution time comparison between different $m$ and $t$ for Successive resultant algorithm.}
  \label{fig:time-EXHA}
\end{subfigure}
\begin{subfigure}{0.48\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{fig/charts_lin.pdf}
  \caption{Execution time comparison between different $m$ and $t$ for Successive resultant algorithm.}
  \label{fig:time-LIN}
\end{subfigure}
\begin{subfigure}{0.48\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{fig/charts_rabin.pdf}
  \caption{Execution time comparison between different $m$ and $t$ for Successive resultant algorithm.}
  \label{fig:time-rabin}
\end{subfigure}

\caption{Plots of measurements time for the five methods presented.}
\label{fig:graph}
\end{figure}

The performance analysis was implemented in Sage\cite{sage}, since we want to measure the execution coast with different parameters, the Sage library permits to us change the field with facility to perform this analysis. We run all proposed methods in a locally Intel\textsuperscript{\tiny\textregistered} Core(TM) i$7$-$4500$U CPU @ $1.80$GHz. The source code of this attack are available on \url{https://github.com/doodomartins/root-finding/soft-factorization}. The Figure~\ref{fig:time-SRA} to Figure~\ref{fig:time-EXHA} presents the execution time for each root finding method.

For each algorithm presented, we can observe the same behaviour on execution time. Since one of the heavy terms in the complexity was the extension $m$, because they affect the algorithm exponentially, we can note that the algorithms has a different growth for each extension, and a greater $m$ will result in a fast growth of the runtime. Moreover, we can observe the huge difference between the extension $2^15 to 2^16$ on the exhaustive search and on the linearized algorithm. 

On the other hand, the degree of the polynomial affects linearly the execution time of the algorithm. Therefore, the execution time growth more slowly when we are increasing the degree of the polynomial. Additionally, we can note a sharp growth on the Successive Resultant and on the Berlekamp Trace when compared to the Miller Algorithm.

\section{Time variance analysis}
The main focus of our works relies on propose alternatives to compute roots of error locator polynomial without leak sensitive information against a timing side-channel attack. As previously presented, a naive implementation of the root finding process allows an attacker to recover the cipher text and compute an session key of a code-based cryptosystem. In order to avoid this attack, we present five algorithms to compute the roots of an polynomial over binary finite fields. For three of these algorithms we propose countermeasures to reduce the time variance on its runtime. On this section we present a time variance analysis of this countermeasures.

In order to measure the time variance, we perform root finding and measure the time variance between different executions. This variance are measure in CPU cycles. Figure \ref{fig:55-60-100} presents the time variance for BTA, Linearized Algorithm and Successive Resultant Algorithm for a polynomial with degree $t = \{55, 60, 100\}$ and $\mathbb{F_2^{16}}$.

\begin{figure}[!ht]
\begin{subfigure}{0.5\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{fig/lin.png}
  \caption{Comparison between linearized polynomials with and without countermeasures.}
  \label{fig:slin}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{fig/bta.png}
  \caption{Comparison between BTA-rf and BTA-it executions.}
  \label{fig:sbta}
\end{subfigure}
\begin{subfigure}{0.48\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{fig/sra.png}
  \caption{Comparison between SRA and Safe SRA executions.}
  \label{fig:ssra}
\end{subfigure}%
\caption{Plots of measurements cycles for methods presented in Sections~\ref{sec:roots}. Our evaluation of SRA was made using a Python implementation and cycles measurement with C. In our tests, the drawback of calling a Python module from C has behavior bordering to constant.}
\label{fig:55-60-100}
\end{figure}

\input{fig/variance12.tex}

In all methods, when we apply our countermeasure, we increase the average execution time. However, we can note that we considerably reduced the time variance of the algorithm. This variance can be observed on the quartiles on Figure~\ref{fig:100_comp_new}. Since the quartiles inside the box represents 50\% of all measured time, and the others quartiles represents the remained 50\%, ignoring the outliers, we can uphold that our countermeasures reduces the time variance of the root finding methods. 

\section{Security overview}
In order to present a security analysis over our countermeasures showed in Chapter~\ref{ch:roots}. Our main hypothesis on the BIGQUAKE attack was the fact that the time variance on the root-finding process leak information about which kind of polynomial was factorized. This approach leads us to recover an cipher message in a few minutes in a normal laptop. Notwithstanding this attack is almost impractical in real cases, we present five countermeasures to avoid this information leakage.

The first countermeasure are based on the direct method, the Exhaustive Search. This method was quite samples to be implemented and with the permutation applied on the elements before the execution of all evaluations we shuffle all elements taking of the chance of an attacker guess the factor based when an extra branch was executed.

Our second countermeasure was applied on the Berlekamp Trace Algorithm, on Linearized Algorithm and on the Successive Resultant Algorithm. The main idea of this countermeasures was present an protected implementation. First one, on the Berlekamp's method, we change the recursive classical implementation to an iterative one. Thus we apply the same techniques in all three methods in order to achieve a reduction on the time variance of each algorithm. This simple strategies was used to blind a timing side-channel attacker with a smaller time variance on the algorithm implementation.  


The last one was the usage of an probabilistic algorithm. The Rabin's method execution it is related to a random choice of an polynomial. All iteration of the algorithm a different random selection was performed. This randomized behavior results in a different execution time for each different execution. Even more, we can't determinate if the time variance of the algorithm between two executions relies of the characteristics of the input polynomial or for the random selections. Since, an attacker measuring the time variance of this algorithm address any sensitive information of a code-based cryptosystem.




