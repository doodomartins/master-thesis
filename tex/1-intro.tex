Communications thought electronic devices require privacy. This privacy between two parts is made with key agreements and key encapsulation protocols or public-key algorithms. During a several years, this protocols was designed over the classical cryptography, which was based on number theory problems. Nowadays, the integer factorization and the discrete logarithm are consider secure. However, the quantum algorithm proposed by Shor~\cite{shor1999polynomial} provides an polynomial time algorithm to solve this numerical problems in a quantum computer. Besides, the recent and fast advances on quantum computing makes necessary the study of new cryptography primitives. 

Furthermore, in recent years, the area of post-quantum cryptography has received considerable attention, especially because of the call by the National Institute of Standards and Technology (NIST) for  standardization of post-quantum schemes. On this call, NIST did not give restrictions about specific hard problems. However, most schemes for the Key Encapsulation Mechanism (KEM) are lattice- and code-based. The latter type is centered around coding theory and includes one of the oldest unbroken cryptosystems, due to McEliece~\cite{mceliece1978public}.

This classical algorithm uses an error-correcting code that able to recovery errors added to a message. This is made through the redundancy added to the original message. Using the idea behind the coding theory, and protecting some parts of the code, only who has knowledge of the code was able to recover the original message. Therefore we can construct schemes based on coding theory which are safe against quantum and classical attacks. Their implementation could not be secure. One of the requirements for those proposals is that they are resistant to all known cryptanalysis methods. In particular, cryptosystems need to avoid side-channel attacks.

There are different ways to apply side-channel attacks to a cryptosystem. As an example, an attacker can measure the execution time of the operations performed by an algorithm and, based on these measurements, estimate some secret information of the scheme. Although the attack scenario it is non-trivial, side-channels attacks are a dangerous mechanism that a cryptosystem needs to taken care of this attack.
 
In code-based cryptography, timing attacks on the decryption process are essentially done during the retrieval of the Error Locator Polynomial (ELP), as is shown by~\cite{shoufan2009timing}. The attack is usually done in the process of evaluating the polynomials, performed to identify the roots. This attack was demonstrated first in~\cite{shoufan2009timing} and later in an improved version in~\cite{bucerzan2017improved}.

In~\cite{strenzke2012fast} the authors made a survey of algorithms and compared they performances to find roots efficiently in code-based cryptosystems. However, the author shows only timings in different types of implementations, and selects the one which has the least timing variability. In other words, the author does not present an algorithm to find the roots in constant time and therefore eliminate the attack, as remarked in~\cite{strenzke2013efficiency}.

The algorithms presented in~\cite{strenzke2012fast} were not created with constant behavior of the implementations in mind. The authors present two optimizations in the exhaustive search method, but these do not affect time variations while the algorithms are in execution. Strenzke further proposes other improvements, some of them in the classical Berlekamp Trace Algorithm~\cite{berlekamp1970factoring} and also in the algorithm proposed in~\cite{fedorenko2002finding}. However, none of these implementations focus on constant-time behaviors or protect the implementation, and thus may leak sensitive information in the decoding process of the McEliece cryptosystem.

The root-finding implementations presented in~\cite{chou2017mcbits, bernstein2013mcbits} use Fast Fourier Transforms (FFT) and, while efficient, they are built and optimized for $\mathbb{F}_{2^{13}}$. We propose a more generic implementation that does not require specific optimizations on the underlying finite field arithmetic. Additionally, this approach takes advantage of a particular computer architecture and uses the fact that we can evaluate multiple points in parallel. We are also interested in approaches that could avoid side channel attacks in any architecture. 

In this work, to evidence the power of a timing side-channel attack, we present a implementation of the Strenzke attack over a NIST Round 1 submission. And the main focus of this works was propose strategies to make the execution time of the aforementioned algorithms constant, additionally, we propose the use of probabilistic algorithms to achieve a safe root computation. One of the strategies is to write the algorithms in an iterative way, eliminating all recursions. We also use permutations and simulated operations to uncouple possible measurements of side effects of the data being measured. Also, 

\section{Objectives}
The main goal of this work is to find alternatives to perform the decoding process of McEliece Cryptosystem in a safe way avoiding timing side-channel attacks. To achieve this, we are interested in building a constant way to compute roots of error locator polynomial, or remove the relation between the polynomial to be factorized and the execution time of the algorithm.


\subsection{Specific objectives}
\begin{enumerate}[label=\roman*., itemsep=1pt]
    \item Perform an timing side-channel attack against a code-based cryptosystem which has non-constant root extraction;
    \item Selection of main methods applied to compute the roots of a polynomial in code-based cryptosystems;
    \item Time variation measurement of works selected in the previous item;
    \item Propose strategies to achieve a secure way to compute roots;
    \item Evaluation of the new time variations of the algorithms;
\end{enumerate}


\section{Methodology}
\section{Scientific contribution}
The timing side-channel attack performed in Chapter~\ref{ch:code-based} and the countermeasures proposed in Chapter~\ref{ch:roots} results in the following paper:

\begin{itemize}
    \item  MARTINS, D.; BANEGAS, G.; CUSTÓDIO, R. Don’t Forget Your Roots: Constant-Time Root Finding over $\mathbb{F}_2^m$. In: International Conference on Cryptology and Information Security in Latin America.  2019. p. 109-129. Available in: \url{https://doi.org/10.1007/978-3-030-30530-7\_6}
\end{itemize}
\section{Organization}



% % 



% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %








% Communications thought electronic devices require privacy. This privacy between two parts is made with key agreements and key encapsulation protocols or public-key algorithms. 

% The context of this work relies on the fact that  Shor's algorithm opens a lack of security in all current cryptosystem. However, there exists a few class of the algorithm that is still secure, against a classical and a quantum computer. One of the most relevant classes of algorithm, called code-based algorithms, are based on the classical work proposed by Robert J. McEliece \cite{mceliece1978public}. 

% This classical algorithm uses an error-correcting code that able to recovery errors added to a message. This is made through the redundancy added to the original message. Using the idea behind the coding theory, and protecting some parts of the code, only who has knowledge of the code was able to recover the original message, we can construct a scheme that is secure in a quantum era. Therefore we can construct schemes based on code secure. Their implementation could not be secure. Based on this fact, many cryptosystems are creating ways to blinding their implementations. 

% In case of schemes based on errors correcting codes, more specific on schemes that uses algebraic decoding, we has some time leakage on the computation of the roots. The main task was, how to compute the roots of an polynomial over finite fields without leak time information. 

% We study, propose modifications, compare and analyze five algorithms that compute the roots of a polynomial.