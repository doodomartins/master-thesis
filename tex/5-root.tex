\section{Exhaustive search}
The exhaustive search is a direct method, in which the evaluation of $f$ for all the elements in $\mathbb{F}_{2^m}$ is performed. A root is found whenever the evaluation result is zero. This method is acceptable for small fields and can be made efficient with a parallel implementation. Algorithm~\ref{alg:exhaustive} describes this method.

As can be seen in Algorithm~\ref{alg:exhaustive}, this method leaks information. This is because whenever a root is found, i.e., $dummy = 0$, an extra operation is performed. In this way, the attacker can infer from this additional time that a root was found, thus providing ways to obtain data that should be secret.

\begin{figure}
\begin{algorithm}[H]
 \KwData{$p(x)$ as univariate polynomial over $\mathbb{F}_{2^m}$ with $d$ roots, $A = [a_0, \ldots, a_{n-1}]$ as all elements in $\mathbb{F}_{2^m}$, $n$ as the length of $A$.}
 \KwResult{$R$ as a set of roots of $p(x)$.}
 $R \gets \emptyset$\;
\For{$i\gets0$ \KwTo $n-1$}{
    $dummy \gets p(A[i])$\;
   \If{$dummy == 0$}{
        $R.add(A[i])$\;
    }
}
\Return $R$\;
  \caption{Exhaustive search algorithm for finding roots of a univariate polynomial over $\mathbb{F}_{2^m}$.}\label{alg:exhaustive}
\end{algorithm}
\end{figure}

One solution to avoid this leakage is to permute the elements of vector $A$. Using this technique, an attacker can identify the extra operation, but without learning any secret information. In our case, we use the Fisher-Yates shuffle~\cite{black2005fisher} for shuffling the elements of vector $A$. In~\cite{wang2018fpga}, the authors show an implementation of the shuffling algorithm safe against timing attacks. Algorithm~\ref{alg:exhaustive_permuted} shows the permutation of the elements and the computation of the roots.

\begin{algorithm}[ht]
 \KwData{$p(x)$ as a univariate polynomial over $\mathbb{F}_{2^m}$ with $d$ roots, $A = [a_0, \ldots, a_{n-1}]$ as all elements in $\mathbb{F}_{2^m}$, $n$ as the length of $A$.}
 \KwResult{$R$ as a set of roots of $p(x)$.}
  permute$(A)$\;
 $R \gets \emptyset$\;
\For{$i\gets0$ \KwTo $n-1$}{
    $dummy \gets p(A[i])$\;
   \If{$dummy == 0$}{
        $R.add(A[i])$\;
    }
}
\Return $R$\;
 \caption{Exhaustive search algorithm with a countermeasure for finding roots of an univariate polynomial over $\mathbb{F}_{2^m}$.}
  \label{alg:exhaustive_permuted}
\end{algorithm}

Using this approach, we add one extra step to the algorithm. However, this permutation blurs the sensitive information of the algorithm, making the usage of Algorithm~\ref{alg:exhaustive_permuted} slightly harder for the attacker to acquire timing leakage.


\section{Berlekamp Trace Algorithm}
In~\cite{berlekamp1970factoring}, Berlekamp presents an efficient algorithm to factor a polynomial, which can be used to find its roots. We call this algorithm \emph{Berlekamp trace algorithm} since it works with a trace function defined as $Tr(x) = x + x^{2} + x^{2^{2}} + \dots + x^{2^{m-1}}$. It is possible to change BTA for finding roots of a polynomial $p(x)$ using $\beta = \{\beta_1, \beta_2, \ldots, \beta_m\}$ as a standard basis of $\mathbb{F}_{2^{m}}$, and then computing the greatest common divisor between $p(x)$ and $Tr(\beta_0 \cdot x)$. After that, it starts a recursion where BTA performs two recursive calls; one with the result of gcd algorithm and the other with the remainder of the division $p(x) / \gcd(p(x), Tr(\beta_i \cdot x))$. The base case is when the degree of the input polynomial is smaller than one. In this case, BTA returns the root, by getting the independent term of the polynomial. In summary, the BTA is a divide and conquer like algorithm since it splits the task of computing the roots of a polynomial $p(x)$ into the roots of two smalls polynomials. The description of BTA algorithm is presented in Algorithm~\ref{alg:bta}.

\begin{algorithm}[ht]
 \KwData{$p(x)$ as a univariate polynomial over $\mathbb{F}_{2^m}$ and i.}
 \KwResult{The set of roots of $p(x)$.}
    \If{$deg(p(x)) \leq 1$}{
        \Return root of $p(x)$\;
    }
    $p_{0}(x) \gets gcd(p(x), Tr(\beta_{i}\cdot x))$\;
    $p_{1}(x) \gets p(x) / p_{0}(x)$ \;
\Return $BTA(p_{0}(x), i + 1) \cup BTA(p_{1}(x), i + 1)$\;
 \caption{Berlekamp Trace Algorithm~\cite{strenzke2012fast} -- $BTA(p(x), i)-rf$.}
  \label{alg:bta}
\end{algorithm}

As we can see, a direct implementation of Algorithm~\ref{alg:bta} has no constant execution time. The recursive behavior may leak information about the characteristics of roots in a side-channel attack. Additionally, in our experiments, we noted that the behavior of the gcd with the trace function may result in a polynomial with the same degree. Therefore, BTA will divide this input polynomial in a future call with a different basis. Consequently, there is no guarantee of a constant number of executions. 

In order to avoid the nonconstant number of executions, here referred as $BTA-it$, we propose an iterative implementation of Algorithm~\ref{alg:bta}. In this way, our proposal iterates in a fixed number of iterations instead of calling itself until the base case. The main idea is not changed; we still divide the task of computing the roots of a polynomial $p(x)$ into two smaller instances. However, we change the approach of the division of the polynomial. Since we want to compute the same number of operations independent of the degree of the polynomial, we perform the gcd with a trace function for all basis in $\beta$, and choose a division that results in two new polynomials with approximate degree.

This new approach allows us to define a fixed number of iterations for our version of BTA. Since we always divide into two small instances, we need $t-1$ iterations to split a polynomial of degree $t$ in $t$ polynomials of degree $1$. Algorithm~\ref{alg:ibta} presents this approach.


\begin{algorithm}[ht]
 \KwData{$p(x)$ as an univariate polynomial over $\mathbb{F}_{2^m}$, $t$ as number of expected roots.}
 \KwResult{The set of roots of $p(x)$.}
    $g \gets \{p(x)\};$ \tcp{The set of polynomials to be computed}
    \For{$k \gets 0$ \KwTo $t$}{
        $current = g.pop()$\;
        Compute $candidates$ $=$ $gcd(current, Tr(\beta_{i}\cdot x))$ $\forall$ $\beta_{i}$ $\in$ $\beta$\;
        Select $p_{0}$ $\in$ $candidates$ such as $p_{0}.degree$ $\simeq$ $\frac{current}{2}$\;
        $p_{1}(x) \gets current / p_{0}(x)$ \;
        \If{$p_{0}.degree == 1$}{
            $R.add($root of $p_{0})$
        } \Else{
            $g.add(p_{0})$\;
        }
        \If{$p_{1}.degree == 1$}{
            $R.add($root of $p_{1})$
        } \Else{
            $g.add(p_{1})$\;
        }
    }
    \Return{$R\;$}
 \caption{Iterative Berlekamp Trace Algorithm -- $BTA(p(x))-it$.}
  \label{alg:ibta}
\end{algorithm}

Algorithm~\ref{alg:ibta} extracts a root of the polynomial when the variable $current$ has a polynomial with degree equal to one. If this degree is greater than one, then the algorithm needs to continue dividing the polynomial until it finds a root. The algorithm does that by adding the polynomial in a stack and reusing this polynomial in a division. 

\section{Linearized Polynomials}
\section{Successive Resultant Algorithm}
\section{Cantor-Zassenhaus Algorithm}
