In this thesis, we propose countermeasures on root-finding algorithms in order to achieve a decoding process without leaking any sensitive information against a timing side-channel attack. We propose five methods, with different characteristics that can be applied to the root extraction task. Our proposals are based on reducing the time variance by applying implementation techniques which aim to construct an algorithm without branches and with constant behavior. 

Before present our countermeasures, we execute a timing attack against a Round 1 NIST proposal, the BIGQUAKE submission. This attack uses the fact that a naive implementation on the decoding process, more specifically, on the root-finding method, leaks information about the polynomial that has been factorized and consequently about the error added to the message. 

The attack is presented to illustrate how insecure a naive implementation is. In our experiments, we detect that the root-finding method was responsible for the major time variance on a root-finding algorithm. Thus, we present five alternatives to construct secure decoding. Our countermeasures are based on Exhaustive search, the Berlekamp Trace Algorithm, the Linearized Algorithm, the Successive Resultant Algorithm, and the Rabin Algorithm. 

These countermeasures were implemented and analyzed in order to measure their time variance and their behavior. In our analysis, we observe that we reduce the time variance for all methods where we propose to reduce this variance. Also, in the probabilistic method, we note that the behavior of the original method does not leak any information about the polynomial that has been factorized. This dissimilarity relies on the fact that the algorithm takes random selection in each iteration.

Finally, we recommend the usage of three root-finding methods presented in this works. First, the use of the new iterative Berlekamp trace algorithm; in our experiments, the BTA method presents a small-time variance. However, it made use of the Euclidean algorithm to compute the $gcd$ in their execution, and it is well known in the literature that the classical implementation of the $gcd$ has no constant time. Second, the usage of the SRA approach, with our countermeasures, it also present a small-time variance; however, their implementation was more complicated because it made use of multivariate polynomial systems.

Lastly, we suggest the usage of the Rabin Algorithm, since it has a random behavior, with no way to infer information from the execution time. This was easily observed on the time execution analysis presented in Figure~\ref{fig:time-rabin}. However, their execution makes use of the $gcd$ algorithm, as in BTA. This could be used to employ a timing attack, however, to the best of our knowledge, any existent timing attack on the literature can infer sufficient information of the $gcd$ to acquire information of the polynomial that was being factorized.

\section{Future works}
For future work, we suggest the following:

\begin{itemize}
    \item Employ the constant time $gcd$ to our implementation: Bernstein and Yand recently propose a constant time approach to perform the $gcd$ algorithm~\cite{Bernstein_Yang_2019}. This new approach claims to solve the problem of a non-constant $gcd$ that our root-finding methods present. 
    \item Uses in a dedicated environment to perform a more detailed analysis: Our implementation was made on a common laptop with a general propose operation system. This implies that are other applications running during the execution of our experiments. To mitigate this, we run ten times each execution and take the average time. However, a dedicate environment can present more precise results to measure the time variance. 
    \item We bring to the attention of the reader that we did not use any optimization in our implementations, i.e., we did not use vectorization or bit slicing techniques or any specific instructions such as Intel\textsuperscript{\tiny\textregistered} IPP Cryptography for finite field arithmetic in our code. Therefore, these techniques and instructions can improve the finite field operations and speed up our algorithms.
    \item We remark that for achieving a safer implementation, one needs to improve the security analysis, by removing conditional memory access and protecting memory access of instructions. Moreover, one can analyze the security of the implementations by considering different attack scenarios and performing an in-depth analysis of hardware side-channel attacks. 
\end{itemize}