In this thesis we propose countermeasures to be applied on root finding algorithms in order to achieve a decoding process without leak any sensitive information against a timing side-channel attack. We propose five methods, with different characteristics which can be applied to the root extraction task. Our proposals are based on reduce the time variance, by applying implementation techniques which aims to construct a algorithm without branches and with a constant behaviour. 

Before present our countermeasures, we present a timing attack against a Round 1 NIST proposal. This attack use the fact that a naive implementation on the decoding process, more specifically, on the root finding method, leak information about the polynomial that has been factorized and consequently about the error added to the message. 

The attack presented illustrate how insecure a naive implementation is. In our experiments we detect that the root finding method was the responsible for the major time variance on a root finding algorithm. Thus, we present five alternatives to construct a safe decoding. Our countermeasures are based on Exhaustive search, the Berlekamp Trace Algorithm, the Linearized Algorithm, the Successive Resultant Algorithm and in the Rabin Algorithm. The countermeasures proposed 

This countermeasures were implemented analysed, in order to measure their time variance and their behaviour. In this analysis we observe that we reduce the time variance for all methods where we propose to reduce this variance. Also, in the probabilistic method, we note that the behaviour of the original method does not leak any information about the polynomial that has been factorized. This relies in the fact that the algorithm takes random selection in each iteration.

Finally, we recommend the usage of three root finding methods presented in this works. First one, the use of the new iterative BTA, in our experiments their present a small time variance, however, their made use of the Euclidean algorithm to compute the $gcd$ in their execution, and it is well know in the literature that the classical implementation of the $gcd$ has no constant time. Second one, the usage of SCA approach, with out countermeasures, their also present an small time variance, however, their implementation it was more complexity because it made use of a multivariate polynomial systems.

Lastly, we suggest the usage of the Rabin Algorithm, since it has a random behaviour, anyone can't infer information from the execution time. This it was observed on the time execution analysis presented in Figure~\ref{fig:time-rabin}. However, their execution made usage of the $gcd$ algorithm, as in BTA. This could be used to employ an timing attack, however, to the best of our knowledge, any existent timing attack on the literature are able to infer sufficient information of the $gcd$ to acquire information of the polynomial that was been factorized.

\section{Future works}
For future work, we suggest the following:

\begin{itemize}
    \item Employ the constant time $gcd$ to our implementation: Bernstein and Yand recently propose an constant time approach to perform the $gcd$ algorithm~\cite{Bernstein_Yang_2019}. This new approach claim to solve the problem of a non-constant $gcd$ that our root finding methods present. 
    \item Implement in a dedicate environment to perform a more detailed analysis: Our implementation was made on a common laptop with a operation system for general propose. This imply that are others applications running during the execution of our experiments. To mitigate this, we run ten times for each execution and take the average time. However, a dedicate environment could present more precises results to measure the time variance. 
    \item We bring to the attention of the reader that we did not use any optimization in our implementations, i.e., we did not use vectorization or bit slicing techniques or any specific instructions such as Intel\textsuperscript{\tiny\textregistered} IPP Cryptography for finite field arithmetic in our code. Therefore, these techniques and instructions can improve the finite fields operations and speed up our algorithms.
    \item We remark that for achieving a safer implementation, one needs to improve the security analysis, by removing conditional memory access and protecting memory access of instructions. Moreover, one can analyze the security of the implementations, by considering different attack scenarios and performing an in-depth analysis of hardware side-channel attacks. 
\end{itemize}